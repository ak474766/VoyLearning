{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 202, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/khana/OneDrive/Desktop/personal%20Project/VoyLearning-main/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/google-genai';\n\nexport const ai = genkit({\n  plugins: [googleAI({apiKey: process.env.GEMINI_API_KEY})],\n  model: 'googleai/gemini-2.5-flash',\n});\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,IAAA,iJAAM,EAAC;IACvB,SAAS;QAAC,IAAA,yLAAQ,EAAC;YAAC,QAAQ,QAAQ,GAAG,CAAC,cAAc;QAAA;KAAG;IACzD,OAAO;AACT","debugId":null}},
    {"offset": {"line": 224, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/khana/OneDrive/Desktop/personal%20Project/VoyLearning-main/src/services/llm/html-editor-agent.ts"],"sourcesContent":["'use server';\nimport { ai } from '@/ai/genkit';\nimport { z } from 'zod';\ntype ModificationType = 'replace' | 'insertAfter' | 'insertBefore' | 'updateText' | 'addImage' | 'appendChild';\n\nexport interface EditInstruction {\n  currentHtml: string;\n  userInstruction: string;\n  imageUrl?: string;\n}\n\nexport interface EditResponse {\n  success: boolean;\n  modifiedHtml?: string;\n  changeDescription?: string;\n  modification?: {\n    targetSelector: string;\n    modificationType: ModificationType;\n    newContent: string;\n    explanation: string;\n    textContent?: string;\n    tagName?: string;\n    index?: number;\n  };\n  error?: string;\n}\n\nconst HtmlModificationSchema = z.object({\n  targetSelector: z.string().describe('CSS selector of the element to modify'),\n  modificationType: z.enum(['replace', 'insertAfter', 'insertBefore', 'updateText', 'addImage', 'appendChild']),\n  newContent: z.string().describe('The new HTML content or text to insert'),\n  explanation: z.string().describe('Brief description of what was changed'),\n  textContent: z.string().optional().describe('Fallback: a short snippet of nearby text to locate the element'),\n  tagName: z.string().optional().describe('Fallback: tag name to narrow the search (e.g., div, h2)'),\n  index: z.number().optional().describe('Fallback: 1-based index among elements with the tagName'),\n});\n\n/**\n * LLM-powered HTML editor that intelligently identifies and modifies specific parts\n */\nexport async function editHtmlWithLLM(instruction: EditInstruction): Promise<EditResponse> {\n  try {\n    // Validate input HTML\n    const validation = validateHtmlServer(instruction.currentHtml);\n    if (!validation.valid) {\n      return {\n        success: false,\n        error: `Invalid HTML: ${validation.errors.join(', ')}`,\n      };\n    }\n\n    // Prepare the prompt for LLM\n    const systemPrompt = `You are an expert HTML editor agent. Your task is to analyze HTML content and user instructions to make precise, targeted modifications.\n\nCRITICAL RULES:\n1. NEVER regenerate the entire HTML document\n2. Identify the EXACT element that needs modification\n3. Provide ONLY the specific content that needs to change\n4. Use precise CSS selectors (prefer ID or class; avoid nth-of-type unless necessary)\n5. Preserve all existing HTML structure, styling, and formatting\n6. For image insertion, if the document contains \".diagram-placeholder\", target that element\n7. Ensure the selector exists in the provided HTML; adjust to an existing class/ID if needed\n8. Also include fallback fields (textContent, tagName, index) that can help locate the target if the selector fails\n\nMODIFICATION TYPES:\n- \"replace\": Replace entire element with new HTML\n- \"updateText\": Change only the text content (preserves tags)\n- \"insertAfter\": Insert new content after the target element\n- \"insertBefore\": Insert new content before the target element\n- \"addImage\": Insert an image after the target element\n- \"appendChild\": Add content as a child of the target element\n\nCurrent HTML Document:\n\\`\\`\\`html\n${instruction.currentHtml}\n\\`\\`\\`\n\nUser Instruction: \"${instruction.userInstruction}\"\n${instruction.imageUrl ? `\\nImage URL to insert: ${instruction.imageUrl}` : ''}\n\nAnalyze the HTML and provide a JSON response with:\n1. targetSelector: The CSS selector for the element to modify\n2. modificationType: One of the types listed above\n3. newContent: The exact HTML/text to insert (keep it minimal)\n4. explanation: Brief description of the change\n\nExample Response:\n{\n  \"targetSelector\": \"h1.main-title\",\n  \"modificationType\": \"updateText\",\n  \"newContent\": \"New Title Text\",\n  \"explanation\": \"Changed the main heading text\"\n}`;\n\n    // Call LLM with retry logic\n    const llmResponse = await retryWithBackoff(async () => {\n      return await ai.generate({\n        prompt: systemPrompt,\n        output: {\n          schema: HtmlModificationSchema,\n        },\n      });\n    });\n\n    // Parse LLM response robustly\n    let modification: z.infer<typeof HtmlModificationSchema> | null = null;\n    const candidate = (llmResponse as any)?.output ?? (llmResponse as any)?.data ?? undefined;\n    if (candidate) {\n      const parsed = HtmlModificationSchema.safeParse(candidate);\n      if (parsed.success) {\n        modification = parsed.data;\n      }\n    }\n    if (!modification) {\n      const text = (llmResponse as any)?.text;\n      if (typeof text === 'string') {\n        try {\n          const json = JSON.parse(text);\n          const parsed = HtmlModificationSchema.safeParse(json);\n          if (parsed.success) {\n            modification = parsed.data;\n          }\n        } catch {\n          // ignore JSON parse errors\n        }\n      }\n    }\n\n    if (!modification) {\n      throw new Error('LLM did not return a valid modification');\n    }\n\n    // If adding an image, use the provided URL\n    let contentToInsert = modification.newContent;\n    if (modification.modificationType === 'addImage' && instruction.imageUrl) {\n      contentToInsert = instruction.imageUrl;\n    }\n\n    // Return modification plan; client will apply DOM changes and sanitize\n    return {\n      success: true,\n      modification: {\n        targetSelector: modification.targetSelector,\n        modificationType: modification.modificationType,\n        newContent: contentToInsert,\n        explanation: modification.explanation,\n        textContent: (modification as any).textContent,\n        tagName: (modification as any).tagName,\n        index: (modification as any).index,\n      },\n      changeDescription: modification.explanation,\n    };\n  } catch (error) {\n    console.error('HTML editing error:', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error occurred',\n    };\n  }\n}\n\n/**\n * Answer questions about HTML content without modifying it\n */\nexport async function answerQuestionAboutHtml(\n  htmlContent: string,\n  question: string\n): Promise<string> {\n  try {\n    const prompt = `You are a helpful learning assistant. Answer the user's question based ONLY on the provided HTML document content. Do not use external knowledge.\n\nHTML Document Content:\n\\`\\`\\`html\n${htmlContent}\n\\`\\`\\`\n\nUser Question: \"${question}\"\n\nProvide a clear, concise answer based on the document content. If the answer cannot be found in the document, say so.`;\n\n    const response = await retryWithBackoff(async () => {\n      return await ai.generate({ prompt });\n    });\n\n    return response.text;\n  } catch (error) {\n    console.error('Question answering error:', error);\n    throw new Error(`Failed to answer question: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n\n\n/**\n * Retry helper with exponential backoff\n */\nasync function retryWithBackoff<T>(fn: () => Promise<T>, retries = 3): Promise<T> {\n  for (let i = 0; i < retries; i++) {\n    try {\n      return await fn();\n    } catch (error) {\n      if (i === retries - 1) throw error;\n      const delay = Math.pow(2, i) * 1000;\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n  throw new Error('Max retries exceeded');\n}\nfunction validateHtmlServer(html: string): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n  if (!html || html.trim().length === 0) errors.push('HTML content is empty');\n  if (html.length > 5000000) errors.push('HTML content exceeds size limit (5MB)');\n  if (!html.includes('<html') && !html.includes('<body')) errors.push('HTML missing basic structure');\n  return { valid: errors.length === 0, errors };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 425, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/khana/OneDrive/Desktop/personal%20Project/VoyLearning-main/.next-internal/server/app/dashboard/fsp/%5BnoteId%5D/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {editHtmlWithLLM as '40ff9fe4e6a6d2f4406f7850ce93a516a802be654a'} from 'ACTIONS_MODULE0'\nexport {answerQuestionAboutHtml as '60364dc76f720cd99afdb2f862e80a5d8830e52102'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}},
    {"offset": {"line": 453, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/khana/OneDrive/Desktop/personal%20Project/VoyLearning-main/src/app/dashboard/fsp/%5BnoteId%5D/page.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/dashboard/fsp/[noteId]/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/dashboard/fsp/[noteId]/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAA2S,GACxU,yEACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 467, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/khana/OneDrive/Desktop/personal%20Project/VoyLearning-main/src/app/dashboard/fsp/%5BnoteId%5D/page.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/dashboard/fsp/[noteId]/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/dashboard/fsp/[noteId]/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAAuR,GACpT,qDACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 481, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}