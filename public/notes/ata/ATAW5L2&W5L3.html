<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      Algorithmic Thinking & Its Applications - Complete Lecture Notes
    </title>

    <!-- MathJax for mathematical equations -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.8;
        color: #333;
        background: linear-gradient(135deg, #f9f9f9 0%, #ffffff 100%);
        padding: 20px;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        padding: 40px;
        border-radius: 15px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
      }

      .header {
        text-align: center;
        padding: 30px 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-radius: 10px;
        margin-bottom: 40px;
      }

      .header h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .header p {
        font-size: 1.2em;
        opacity: 0.9;
      }

      .toc {
        background: #f8f9fa;
        padding: 30px;
        border-radius: 10px;
        margin: 30px 0;
        border-left: 5px solid #667eea;
      }

      .toc h2 {
        color: #667eea;
        margin-bottom: 20px;
        font-size: 1.8em;
      }

      .toc ul {
        list-style: none;
      }

      .toc ul li {
        padding: 10px 0;
        border-bottom: 1px solid #e0e0e0;
      }

      .toc ul li:last-child {
        border-bottom: none;
      }

      .toc a {
        color: #667eea;
        text-decoration: none;
        font-size: 1.1em;
        transition: all 0.3s;
        display: block;
      }

      .toc a:hover {
        color: #764ba2;
        padding-left: 10px;
      }

      h2 {
        color: #667eea;
        margin: 40px 0 20px 0;
        font-size: 2em;
        border-bottom: 3px solid #667eea;
        padding-bottom: 10px;
      }

      h3 {
        color: #764ba2;
        margin: 30px 0 15px 0;
        font-size: 1.5em;
      }

      h4 {
        color: #555;
        margin: 20px 0 10px 0;
        font-size: 1.2em;
      }

      p {
        margin: 15px 0;
        text-align: justify;
      }

      strong,
      .key-term {
        color: #764ba2;
        font-weight: bold;
        background: #f0e6ff;
        padding: 2px 6px;
        border-radius: 3px;
      }

      .highlight {
        background: #fff3cd;
        padding: 15px;
        border-left: 4px solid #ffc107;
        margin: 20px 0;
        border-radius: 5px;
      }

      .professor-note {
        background: #e7f3ff;
        padding: 15px;
        border-left: 4px solid #2196f3;
        margin: 20px 0;
        border-radius: 5px;
      }

      .professor-note::before {
        content: "üë®‚Äçüè´ Professor mentioned in class: ";
        font-weight: bold;
        color: #2196f3;
      }

      .hinglish-summary {
        background: #e8f5e9;
        padding: 20px;
        border-radius: 10px;
        margin: 25px 0;
        border-left: 5px solid #4caf50;
      }

      .hinglish-summary h4 {
        color: #4caf50;
        margin-bottom: 10px;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin: 25px 0;
        box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
      }

      table th {
        background: #667eea;
        color: white;
        padding: 15px;
        text-align: left;
        font-weight: bold;
      }

      table td {
        padding: 15px;
        border-bottom: 1px solid #e0e0e0;
      }

      table tr:hover {
        background: #f5f5f5;
      }

      .code-block {
        background: #282c34;
        color: #abb2bf;
        padding: 20px;
        border-radius: 8px;
        margin: 20px 0;
        overflow-x: auto;
        font-family: "Courier New", monospace;
        line-height: 1.6;
        /* Preserve whitespace and line breaks so code displays correctly */
        white-space: pre-wrap;
        word-wrap: break-word;
      }

      .flowchart-box {
        background: #fff;
        border: 2px solid #667eea;
        padding: 15px;
        margin: 20px 0;
        border-radius: 8px;
        text-align: center;
      }

      .diagram-placeholder {
        background: #f0f0f0;
        border: 2px dashed #999;
        padding: 40px;
        text-align: center;
        margin: 20px 0;
        border-radius: 8px;
        color: #666;
        font-style: italic;
      }

      .practice-questions {
        background: #fff3e0;
        padding: 25px;
        border-radius: 10px;
        margin: 30px 0;
        border-left: 5px solid #ff9800;
      }

      .practice-questions h4 {
        color: #ff9800;
        margin-bottom: 15px;
      }

      .question {
        margin: 15px 0;
        padding: 15px;
        background: white;
        border-radius: 5px;
      }

      .answer {
        margin-top: 10px;
        padding: 10px;
        background: #e8f5e9;
        border-radius: 5px;
        border-left: 3px solid #4caf50;
      }

      .key-takeaways {
        background: #fce4ec;
        padding: 25px;
        border-radius: 10px;
        margin: 30px 0;
        border-left: 5px solid #e91e63;
      }

      .key-takeaways h4 {
        color: #e91e63;
        margin-bottom: 15px;
      }

      .key-takeaways ul {
        list-style-position: inside;
      }

      .key-takeaways li {
        padding: 8px 0;
      }

      ul,
      ol {
        margin: 15px 0 15px 30px;
      }

      li {
        margin: 8px 0;
      }

      .example-box {
        background: #e3f2fd;
        padding: 20px;
        border-radius: 8px;
        margin: 20px 0;
        border-left: 4px solid #2196f3;
      }

      .example-box h4 {
        color: #1976d2;
        margin-bottom: 10px;
      }

      .mind-map {
        background: #f5f5f5;
        padding: 30px;
        border-radius: 10px;
        margin: 40px 0;
      }

      .mind-map h2 {
        text-align: center;
        color: #667eea;
        margin-bottom: 30px;
      }

      .mind-map-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-around;
      }

      .mind-map-node {
        background: white;
        border: 3px solid #667eea;
        border-radius: 10px;
        padding: 20px;
        margin: 15px;
        min-width: 250px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      }

      .mind-map-node h3 {
        color: #667eea;
        margin-bottom: 15px;
        text-align: center;
      }

      .mind-map-node ul {
        list-style: none;
        margin: 0;
      }

      .mind-map-node li {
        padding: 8px 0;
        border-bottom: 1px solid #e0e0e0;
      }

      .mind-map-node li:last-child {
        border-bottom: none;
      }

      @media (max-width: 768px) {
        .container {
          padding: 20px;
        }

        .header h1 {
          font-size: 1.8em;
        }

        h2 {
          font-size: 1.5em;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üéì Algorithmic Thinking & Its Applications</h1>
        <h1>ATA Week 5</h1>
        <h1>Lecture 2 & 3 Notes</h1>
      </div>

      <!-- Table of Contents -->
      <div class="toc" id="toc">
        <h2>üìö Table of Contents</h2>
        <ul>
          <li>
            <a href="#introduction">1. Introduction to Algorithmic Thinking</a>
          </li>
          <li><a href="#problem-solving">2. Problem-Solving Process</a></li>
          <li><a href="#problem-understanding">3. Problem Understanding</a></li>
          <li><a href="#solution-design">4. Solution Design</a></li>
          <li><a href="#variables">5. Understanding Variables</a></li>
          <li><a href="#stepwise-refinement">6. Stepwise Refinement</a></li>
          <li>
            <a href="#digit-counting">7. Practical Example: Counting Digits</a>
          </li>
          <li>
            <a href="#number-reversal"
              >8. Practical Example: Reversing Numbers</a
            >
          </li>
          <li>
            <a href="#flowcharts">9. Flowcharts and Computational Thinking</a>
          </li>
          <li><a href="#pseudocode">10. Introduction to Pseudocode</a></li>
          <li>
            <a href="#class-average"
              >11. Detailed Example: Computing Class Average</a
            >
          </li>
          <li><a href="#parking-lot">12. Example: Parking Lot Program</a></li>
          <li><a href="#practice">13. Practice Questions</a></li>
          <li><a href="#mind-map">14. Comprehensive Mind Map</a></li>
        </ul>
      </div>

      <!-- Section 1: Introduction -->
      <section id="introduction">
        <h2>1. Introduction to Algorithmic Thinking</h2>

        <p>
          Welcome to this comprehensive lecture on
          <strong>Algorithmic Thinking and Its Applications</strong>. This
          course is designed to transition you from theoretical problem-solving
          concepts to practical programming implementations, particularly using
          Python.
        </p>

        <h3>Course Overview</h3>
        <p>
          In this course, we will dive deeper into several fundamental topics:
        </p>

        <ul>
          <li>
            <strong>Problem Decomposition</strong>: Breaking complex problems
            into manageable subtasks
          </li>
          <li>
            <strong>Algorithm Generation</strong>: Creating step-by-step
            solutions
          </li>
          <li>
            <strong>Logic Design</strong>: Understanding how to structure
            computational thinking
          </li>
          <li>
            <strong>Solution Verification</strong>: Checking correctness and
            efficiency
          </li>
          <li>
            <strong>Optimization</strong>: Making solutions better and more
            efficient
          </li>
        </ul>

        <div class="professor-note">
          The main focus is transitioning from pen-and-paper design to actual
          programming implementation. We'll slowly move from theoretical
          perspectives to the domain of programming languages, specifically
          Python, which will be the primary language for this course.
        </div>

        <h3>The Iterative Design Process</h3>
        <p>
          Problem-solving in computer science follows an
          <strong>iterative pattern</strong>:
        </p>

        <ol>
          <li><strong>Define</strong> the problem clearly</li>
          <li><strong>Understand</strong> the broad solution approach</li>
          <li><strong>Implement</strong> the solution</li>
          <li><strong>Evaluate</strong> if the solution is correct</li>
          <li><strong>Refine</strong> and repeat if improvements are needed</li>
        </ol>

        <div class="highlight">
          <strong>Important Note:</strong> These abstractions are easier said
          than done. You can only become very good at algorithmic thinking
          through practice. The more problems you solve, the more examples you
          work through, and the more books you read, the better you'll become.
        </div>

        <div class="hinglish-summary">
          <h4>üìù Hinglish Summary</h4>
          <p>
            Iss course mein hum problem-solving ko theoretical level se
            practical programming tak le jayenge. Main focus hai ki kaise aap ek
            problem ko chote-chote parts mein todo, uska logic design karo, aur
            finally verify karo ki solution sahi hai ya nahi. Practice se hi aap
            isme expert ban sakte ho - jitna zyada practice karoge, utna better
            hoga.
          </p>
        </div>
      </section>

      <!-- Section 2: Problem-Solving Process -->
      <section id="problem-solving">
        <h2>2. Problem-Solving Process</h2>

        <p>
          The problem-solving process consists of several interconnected stages
          that guide us from problem identification to solution implementation.
        </p>

        <table>
          <thead>
            <tr>
              <th>Stage</th>
              <th>Description</th>
              <th>Key Activities</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Problem Analysis</strong></td>
              <td>Understanding what needs to be solved</td>
              <td>Identify inputs, outputs, constraints</td>
            </tr>
            <tr>
              <td><strong>Alternative Consideration</strong></td>
              <td>Exploring different approaches</td>
              <td>Brainstorm multiple solution strategies</td>
            </tr>
            <tr>
              <td><strong>Choosing an Approach</strong></td>
              <td>Selecting the best strategy</td>
              <td>Evaluate pros and cons of each approach</td>
            </tr>
            <tr>
              <td><strong>Problem Decomposition</strong></td>
              <td>Breaking down into subtasks</td>
              <td>Divide complex problem into manageable parts</td>
            </tr>
            <tr>
              <td><strong>Algorithm Development</strong></td>
              <td>Creating step-by-step solution</td>
              <td>Design flowcharts, pseudocode</td>
            </tr>
            <tr>
              <td><strong>Algorithm Correctness</strong></td>
              <td>Verifying the solution works</td>
              <td>Test with sample inputs</td>
            </tr>
            <tr>
              <td><strong>Algorithm Efficiency</strong></td>
              <td>Checking performance</td>
              <td>Analyze time and space complexity</td>
            </tr>
            <tr>
              <td><strong>Reflection</strong></td>
              <td>Reviewing and improving</td>
              <td>Identify areas for optimization</td>
            </tr>
          </tbody>
        </table>

        <div class="key-takeaways">
          <h4>üîë Key Takeaways</h4>
          <ul>
            <li>Problem-solving is an iterative, not linear, process</li>
            <li>Each stage builds upon the previous one</li>
            <li>Reflection and refinement are crucial for improvement</li>
            <li>
              Multiple iterations may be needed to reach an optimal solution
            </li>
          </ul>
        </div>

        <div class="hinglish-summary">
          <h4>üìù Hinglish Summary</h4>
          <p>
            Problem-solving ek circular process hai jismein 8 main stages hain -
            analysis se lekar reflection tak. Har stage important hai aur ek
            dusre se connected hai. Agar solution pehli baar mein perfect nahi
            bana, toh koi baat nahi - process ko repeat karo aur better banao.
            Ye ek continuous improvement ka cycle hai.
          </p>
        </div>
      </section>

      <!-- Section 3: Problem Understanding -->
      <section id="problem-understanding">
        <h2>3. Problem Understanding</h2>

        <p>
          <strong>Problem Understanding</strong> is the foundational step that
          leads to the identification of problem characteristics. For
          algorithmic problems, this involves recognizing input categories and
          selecting required output categories.
        </p>

        <h3>Four Basic Strategies</h3>

        <div class="example-box">
          <h4>Strategy 1: Identify Inputs</h4>
          <p>
            <strong>Question to ask:</strong> What data will the program
            receive?
          </p>
          <p>For every problem, clearly identify:</p>
          <ul>
            <li>What type of data (numbers, text, etc.)</li>
            <li>How many inputs are needed</li>
            <li>What format the inputs will be in</li>
            <li>Are there any constraints on the inputs?</li>
          </ul>
        </div>

        <div class="example-box">
          <h4>Strategy 2: Identify Outputs</h4>
          <p>
            <strong>Question to ask:</strong> What should the program produce?
          </p>
          <p>Clearly define:</p>
          <ul>
            <li>What the final result should look like</li>
            <li>In what format should it be presented</li>
            <li>What are the expected outcomes for different inputs</li>
          </ul>
        </div>

        <div class="example-box">
          <h4>Strategy 3: Each Input as a Subtask</h4>
          <p>
            Break down the problem by treating each input category as a separate
            subtask. This helps in managing complexity and designing modular
            solutions.
          </p>
        </div>

        <div class="example-box">
          <h4>Strategy 4: Consider Extreme Cases</h4>
          <p>Always test your logic with:</p>
          <ul>
            <li>Minimum possible values</li>
            <li>Maximum possible values</li>
            <li>Boundary conditions (like zero, negative numbers)</li>
            <li>Special cases that might break the logic</li>
          </ul>
        </div>

        <div class="professor-note">
          If you don't understand what exactly your inputs are and what outputs
          are expected from the program, then your understanding will not be
          complete. These are absolutely critical first steps before writing any
          code.
        </div>

        <h3>The Input-Process-Output Model</h3>

        <p>
          Computers fundamentally follow the
          <strong>von Neumann architecture</strong>:
        </p>

        <div class="flowchart-box">
          <p>
            <strong>INPUT</strong> ‚Üí <strong>PROCESS (CPU/ALU)</strong> ‚Üí
            <strong>OUTPUT</strong>
          </p>
        </div>

        <table>
          <thead>
            <tr>
              <th>Component</th>
              <th>Function</th>
              <th>Examples</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Input Devices</strong></td>
              <td>Receive data from external sources</td>
              <td>Keyboard, mouse, sensors, files</td>
            </tr>
            <tr>
              <td><strong>CPU (ALU)</strong></td>
              <td>Process data using arithmetic and logic operations</td>
              <td>
                Addition, subtraction, multiplication, division, comparisons
              </td>
            </tr>
            <tr>
              <td><strong>Memory</strong></td>
              <td>Store data temporarily during processing</td>
              <td>RAM, variables, data structures</td>
            </tr>
            <tr>
              <td><strong>Output Devices</strong></td>
              <td>Present results to users</td>
              <td>Screen, printer, speakers, files</td>
            </tr>
          </tbody>
        </table>

        <div class="highlight">
          <strong>Key Concept:</strong> Any data coming from memory to the
          processor is INPUT, and any data going from processor to memory is
          OUTPUT. The CPU primarily performs basic arithmetic operations -
          addition, subtraction, multiplication, division, and logical
          comparisons.
        </div>

        <div class="hinglish-summary">
          <h4>üìù Hinglish Summary</h4>
          <p>
            Problem ko samajhne ke liye sabse pehle inputs aur outputs ko
            clearly identify karna zaroori hai. Har computer basically teen kaam
            karta hai - input leta hai, process karta hai (arithmetic operations
            se), aur output deta hai. Extreme cases ko test karna mat bhoolo
            kyunki wahan pe hi bugs aate hain. Input-output clear nahi hai toh
            solution bhi sahi nahi hoga.
          </p>
        </div>
      </section>

      <!-- Section 4: Solution Design -->
      <section id="solution-design">
        <h2>4. Solution Design</h2>

        <p>
          <strong>Solution Design</strong> is the major challenge facing novice
          learners. After examining inputs and outputs, the next critical stage
          is defining the variables needed to solve the problem.
        </p>

        <h3>Key Challenges in Solution Design</h3>

        <ul>
          <li>
            <strong>Converting real-world problems</strong> into computational
            steps
          </li>
          <li>
            <strong>Choosing appropriate data structures</strong> to represent
            information
          </li>
          <li>
            <strong>Designing efficient algorithms</strong> that solve the
            problem correctly
          </li>
          <li><strong>Handling edge cases</strong> and unexpected inputs</li>
        </ul>

        <h3>Basic Strategies for Solution Design</h3>

        <table>
          <thead>
            <tr>
              <th>Strategy</th>
              <th>Description</th>
              <th>When to Use</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Define Problem Variables</strong></td>
              <td>Identify all data that needs to be stored</td>
              <td>At the beginning of solution design</td>
            </tr>
            <tr>
              <td><strong>Stepwise Refinement</strong></td>
              <td>Break solution into progressively detailed steps</td>
              <td>For complex problems requiring decomposition</td>
            </tr>
            <tr>
              <td><strong>Identify Algorithmic Patterns</strong></td>
              <td>Recognize repetition, sequence, selection patterns</td>
              <td>When designing the control flow</td>
            </tr>
          </tbody>
        </table>

        <div class="professor-note">
          Once the set of steps is well-defined through proper problem
          understanding and variable identification, it becomes very easy to
          design the solution. The clarity of inputs and outputs directly
          impacts how smoothly you can proceed with solution design.
        </div>

        <div class="hinglish-summary">
          <h4>üìù Hinglish Summary</h4>
          <p>
            Solution design beginners ke liye sabse badi challenge hai.
            Inputs-outputs clear karne ke baad, next step hai variables define
            karna jo problem solve karne ke liye chahiye. Teen main strategies
            hain - variables define karo, stepwise refinement use karo, aur
            algorithmic patterns (jaise loops, conditions) pehchano. Proper
            planning se solution design asaan ho jata hai.
          </p>
        </div>
      </section>

      <!-- Section 5: Variables -->
      <section id="variables">
        <h2>5. Understanding Variables</h2>

        <p>
          A <strong>variable</strong> can be thought of as a
          <strong>box that can hold one value at a time</strong>. This is a
          fundamental concept that bridges mathematics and computer science.
        </p>

        <h3>Variables in Mathematics vs. Computer Science</h3>

        <table>
          <thead>
            <tr>
              <th>Aspect</th>
              <th>Mathematics</th>
              <th>Computer Science</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Representation</strong></td>
              <td>Symbols (x, y, z) representing quantities</td>
              <td>Named memory locations storing values</td>
            </tr>
            <tr>
              <td><strong>Size Limits</strong></td>
              <td>Generally unlimited (theoretical)</td>
              <td>Limited by memory and data type</td>
            </tr>
            <tr>
              <td><strong>Value Changes</strong></td>
              <td>Typically constant in equations</td>
              <td>Can change during program execution</td>
            </tr>
            <tr>
              <td><strong>Storage</strong></td>
              <td>Abstract concept</td>
              <td>Physical memory location</td>
            </tr>
          </tbody>
        </table>

        <h3>The Box Analogy</h3>

        <p>
          Think of a variable as a <strong>box with a tag</strong> attached to
          it:
        </p>

        <div class="example-box">
          <h4>The Box</h4>
          <ul>
            <li>
              Represents a <strong>memory location</strong> in the computer
            </li>
            <li>
              Has a <strong>fixed size</strong> (unlike mathematical variables)
            </li>
            <li>Cannot be moved or relocated (fixed address)</li>
            <li>Can only hold <strong>one value at a time</strong></li>
            <li>
              The value inside can be changed, but the location remains the same
            </li>
          </ul>
        </div>

        <div class="example-box">
          <h4>The Tag</h4>
          <ul>
            <li>This is the <strong>variable name</strong> (identifier)</li>
            <li>Can be moved from one box to another</li>
            <li>
              Provides a human-readable way to reference the memory location
            </li>
            <li>Makes code understandable and maintainable</li>
          </ul>
        </div>

        <h3>Memory as an Apartment Complex</h3>

        <div class="professor-note">
          Think of computer memory like a hotel or apartment complex. Each room
          (memory location) is typically one byte in size. Just like a family of
          4 adults might need 2 hotel rooms, some data types need more than one
          byte of memory. The room numbers can be changed (like variable names),
          but you cannot physically move the rooms themselves. The memory
          locations are fixed.
        </div>

        <div class="diagram-placeholder">
          [Insert diagram: Memory as apartment complex with boxes representing
          bytes, showing how variables occupy one or more bytes]
        </div>

        <h3>Key Properties of Variables</h3>

        <ol>
          <li>
            <strong>Limited Size:</strong> Variables have bounds - they cannot
            hold infinitely large or small values
          </li>
          <li>
            <strong>Fixed Location:</strong> Memory addresses don't move; only
            the names (tags) can be reassigned
          </li>
          <li>
            <strong>Single Value:</strong> A variable can only store one value
            at a time (the current value)
          </li>
          <li>
            <strong>Data Type:</strong> Different types of data require
            different amounts of memory
          </li>
        </ol>

        <h3>Variable Initialization</h3>

        <div class="highlight">
          <strong>Critical Concept:</strong> When a variable is created, the
          "room" may contain leftover data from previous programs (like an
          uncleaned hotel room). This is why <strong>initialization</strong> is
          crucial - you must set the variable to a known value (often 0) before
          using it.
        </div>

        <div class="example-box">
          <h4>Example: Why Initialization Matters</h4>
          <p>
            If you're computing a sum and don't initialize your sum variable to
            0:
          </p>
          <ul>
            <li>The memory location might contain random value like 547</li>
            <li>
              Adding to this gives incorrect results: 547 + 10 + 20 + 30 = 607
              (wrong!)
            </li>
            <li>
              With proper initialization to 0: 0 + 10 + 20 + 30 = 60 (correct!)
            </li>
          </ul>
        </div>

        <pre class="code-block"><code>// Good Practice - Always Initialize
sum = 0          // Clean the room first
count = 0        // Start from known state
total = 0        // Prevents unexpected results
</code></pre>

        <div class="key-takeaways">
          <h4>üîë Key Takeaways</h4>
          <ul>
            <li>Variables are memory locations (boxes) with names (tags)</li>
            <li>
              Memory locations are fixed; variable names can be reassigned
            </li>
            <li>Variables have size limitations based on data type</li>
            <li>
              Always initialize variables before use to avoid garbage values
            </li>
            <li>
              Understanding variables is essential for proper solution design
            </li>
          </ul>
        </div>

        <div class="hinglish-summary">
          <h4>üìù Hinglish Summary</h4>
          <p>
            Variable ek box hai jo computer ke memory mein hota hai aur ek value
            hold karta hai. Box fixed hai (move nahi hota) lekin uska tag (naam)
            change ho sakta hai. Mathematics mein variable unlimited ho sakta
            hai, lekin computer mein har variable ka size limited hota hai.
            Important baat: variable ko use karne se pehle initialize karna
            zaroori hai (jaise 0 set karna) warna purane garbage values se galat
            result aa sakta hai. Memory ko hotel ke rooms jaisa samjho - har
            room fixed hai aur uska size limited hai.
          </p>
        </div>
      </section>

      <!-- Section 6: Stepwise Refinement -->
      <section id="stepwise-refinement">
        <h2>6. Stepwise Refinement</h2>

        <p>
          <strong>Stepwise Refinement</strong> (also called
          <strong>Top-Down Design</strong>) is a methodology that first obtains
          the overview structure of the problem and the relationship among each
          part, then addresses specific and complex issues related to the
          implementation of subparts.
        </p>

        <h3>Historical Background</h3>

        <div class="highlight">
          <p>
            <strong>Origin:</strong> The concept was introduced by
            <strong>Niklaus Wirth</strong> in his 1971 paper titled
            <em>"Program Development by Stepwise Refinement"</em> published in
            Communications of the ACM, Vol. 14 (4), pp. 221-227.
          </p>
          <p>
            <strong>Wirth's Definition:</strong> "It is here considered as a
            sequence of design decisions concerning the decomposition of tasks
            into subtasks and of data into data structures."
          </p>
        </div>

        <div class="professor-note">
          Niklaus Wirth is the creator of the Pascal programming language and
          made major contributions to software design and software engineering.
          His stepwise refinement methodology revolutionized how programmers
          approach problem-solving.
        </div>

        <h3>The Stepwise Refinement Process</h3>

        <div class="flowchart-box">
          <p style="font-weight: bold">
            Step 1: Start with Initial Problem Statement
          </p>
          <p>‚Üì</p>
          <p style="font-weight: bold">Step 2: Break into General Steps</p>
          <p>‚Üì</p>
          <p style="font-weight: bold">Step 3: Refine Each Step Further</p>
          <p>‚Üì</p>
          <p style="font-weight: bold">Step 4: Repeat Until Pseudocode Level</p>
          <p>‚Üì</p>
          <p style="font-weight: bold">Step 5: Translate to Real Code</p>
        </div>

        <h3>Detailed Steps</h3>

        <ol>
          <li>
            <strong>Start with the initial problem statement</strong>
            <ul>
              <li>Read and understand the problem thoroughly</li>
              <li>Identify main objectives</li>
            </ul>
          </li>
          <li>
            <strong>Break it into a few general steps</strong>
            <ul>
              <li>Create 3-5 high-level steps</li>
              <li>Focus on major tasks only</li>
            </ul>
          </li>
          <li>
            <strong>Take each "step" and break it further</strong>
            <ul>
              <li>Add more detail to each general step</li>
              <li>Identify sub-operations needed</li>
            </ul>
          </li>
          <li>
            <strong>Keep repeating the process</strong>
            <ul>
              <li>Continue until steps are very specific</li>
              <li>Stop when you can write pseudocode</li>
            </ul>
          </li>
          <li>
            <strong>Translate pseudocode into real code</strong>
            <ul>
              <li>Convert to actual programming language</li>
              <li>Follow language syntax and rules</li>
            </ul>
          </li>
        </ol>

        <h3>Why Data Representation Matters</h3>

        <div class="professor-note">
          Think about traveling on a train with your family of 4 people. If your
          seats are scattered across different compartments, communication and
          coordination become difficult. Similarly, if data is scattered across
          memory, your algorithm design becomes more complex. How data is stored
          directly impacts how you decompose the problem. This is why data
          structures are so important!
        </div>

        <div class="example-box">
          <h4>Analogy: Train Seats vs. Memory Locations</h4>
          <table>
            <thead>
              <tr>
                <th>Scenario</th>
                <th>Train Travel</th>
                <th>Computer Memory</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Together</strong></td>
                <td>Family seated together - easy coordination</td>
                <td>Related data in contiguous memory - efficient access</td>
              </tr>
              <tr>
                <td><strong>Scattered</strong></td>
                <td>
                  Family in different compartments - difficult to coordinate
                </td>
                <td>
                  Data distributed across memory - complex algorithms needed
                </td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="key-takeaways">
          <h4>üîë Key Takeaways</h4>
          <ul>
            <li>
              Stepwise refinement is a top-down, progressive approach to
              problem-solving
            </li>
            <li>Start broad and general, then add detail iteratively</li>
            <li>Data structure design directly impacts algorithm design</li>
            <li>
              The decomposition continues until steps are specific enough to
              code
            </li>
            <li>This methodology works for both simple and complex problems</li>
          </ul>
        </div>

        <div class="hinglish-summary">
          <h4>üìù Hinglish Summary</h4>
          <p>
            Stepwise refinement matlab hai top-down approach - pehle badi
            picture dekho, phir detail mein jao. Problem ko broad steps mein
            todo, phir har step ko aur chota karo, jab tak ki tum pseudocode
            nahi likh sakte. Niklaus Wirth ne 1971 mein ye concept diya tha.
            Important point: data kaise store hai, usse algorithm design pe bada
            fark padta hai - jaise train mein family ke seats ek saath ho toh
            coordination easy hai, waise hi memory mein related data ek saath ho
            toh algorithm simple ho jata hai.
          </p>
        </div>
      </section>

      <!-- Section 7: Digit Counting Example -->
      <section id="digit-counting">
        <h2>7. Practical Example: Counting Digits</h2>

        <p>
          Let's understand how to count the number of digits in a given number
          using algorithmic thinking.
        </p>

        <h3>Problem Statement</h3>
        <div class="example-box">
          <h4>Given a number, find:</h4>
          <ul>
            <li>How many digits it contains</li>
            <li>The sum of all digits</li>
          </ul>
          <p><strong>Example:</strong> Number = 5461</p>
          <ul>
            <li>Number of digits = 4</li>
            <li>Sum of digits = 5 + 4 + 6 + 1 = 16</li>
          </ul>
        </div>

        <h3>Understanding the Challenge</h3>

        <div class="professor-note">
          What is the crux (main challenge) of this problem? The main challenge
          is finding out WHERE THE NUMBER ACTUALLY ENDS. You can't count
          forever! You need to understand that once the number becomes zero, you
          must stop counting. This is the key insight.
        </div>

        <h3>Solution Strategy</h3>

        <p>The most effective approach is:</p>
        <ol>
          <li><strong>Count one digit at a time</strong></li>
          <li>
            <strong>Truncate the number</strong> (remove the counted digit)
          </li>
          <li><strong>Repeat until the number becomes zero</strong></li>
        </ol>

        <h3>Step-by-Step Walkthrough</h3>

        <div class="example-box">
          <h4>Example: Counting digits in 5461</h4>
          <table>
            <thead>
              <tr>
                <th>Step</th>
                <th>Current Number</th>
                <th>Operation</th>
                <th>Count</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Start</td>
                <td>5461</td>
                <td>-</td>
                <td>0</td>
              </tr>
              <tr>
                <td>1</td>
                <td>5461 √∑ 10 = 546</td>
                <td>Integer division</td>
                <td>1</td>
              </tr>
              <tr>
                <td>2</td>
                <td>546 √∑ 10 = 54</td>
                <td>Integer division</td>
                <td>2</td>
              </tr>
              <tr>
                <td>3</td>
                <td>54 √∑ 10 = 5</td>
                <td>Integer division</td>
                <td>3</td>
              </tr>
              <tr>
                <td>4</td>
                <td>5 √∑ 10 = 0</td>
                <td>Integer division</td>
                <td>4</td>
              </tr>
              <tr>
                <td>End</td>
                <td>0</td>
                <td>Stop (number is zero)</td>
                <td><strong>4 digits</strong></td>
              </tr>
            </tbody>
          </table>
        </div>

        <h3>Key Technique: Integer Division</h3>

        <div class="highlight">
          <strong>Important Concept:</strong> We use
          <strong>whole number division</strong> (integer division) where
          there's no place to store decimal parts or fractions. Even if the
          result is 546.1, only 546 gets stored because we're doing integer
          division.
        </div>

        <pre class="code-block"><code>Example of Integer Division:
5461 √∑ 10 = 546.1 ‚Üí stored as 546 (decimal dropped)
546 √∑ 10 = 54.6 ‚Üí stored as 54
54 √∑ 10 = 5.4 ‚Üí stored as 5
5 √∑ 10 = 0.5 ‚Üí stored as 0

The magnitude reduces at each step!
</code></pre>

        <h3>Algorithm in Pseudocode</h3>

        <pre class="code-block"><code>ALGORITHM: Count Digits

1. Initialize count = 0
2. Input number N
3. WHILE N is not equal to 0:
    a. Increment count by 1
    b. Divide N by 10 (integer division)
    c. Store result back in N
4. Print count
5. END
</code></pre>

        <div class="professor-note">
          This process continues until the number becomes zero. Once it's zero,
          we know we've counted all the digits. The number of steps equals the
          number of digits. Simple yet powerful!
        </div>

        <div class="key-takeaways">
          <h4>üîë Key Takeaways</h4>
          <ul>
            <li>The crux is knowing when the number ends (becomes zero)</li>
            <li>Process one digit at a time for simplicity</li>
            <li>Integer division automatically truncates decimal parts</li>
            <li>Loop continues while number is not zero</li>
            <li>Count variable tracks how many iterations occurred</li>
          </ul>
        </div>

        <div class="hinglish-summary">
          <h4>üìù Hinglish Summary</h4>
          <p>
            Digits count karne ke liye main challenge hai ye pata lagana ki
            number kab khatam hoga. Simple solution: ek-ek digit count karo aur
            number ko 10 se divide karte jao (integer division). Jab number 0 ho
            jaye, ruk jao. For example, 5461 ko divide karte jao - 546, 54, 5, 0
            - total 4 steps matlab 4 digits. Integer division automatically
            decimal part ko cut kar deta hai, isliye ye technique perfect kaam
            karti hai.
          </p>
        </div>
      </section>

      <!-- Section 8: Number Reversal -->
      <section id="number-reversal">
        <h2>8. Practical Example: Reversing Numbers</h2>

        <p>
          Building on the digit-counting technique, let's explore how to reverse
          a number - another fundamental algorithmic problem.
        </p>

        <h3>Problem Statement</h3>
        <div class="example-box">
          <h4>Given a number, reverse its digits</h4>
          <p><strong>Example:</strong></p>
          <ul>
            <li>Input: 5461</li>
            <li>Output: 1645</li>
          </ul>
        </div>

        <h3>Solution Strategy</h3>

        <p>The approach involves:</p>
        <ol>
          <li><strong>Extract the last digit</strong> (unit's place)</li>
          <li><strong>Store it</strong> in a new number</li>
          <li><strong>Shift left</strong> (make space for next digit)</li>
          <li><strong>Repeat</strong> until original number becomes zero</li>
        </ol>

        <h3>Visual Walkthrough</h3>

        <div class="example-box">
          <h4>Reversing 5461:</h4>
          <table>
            <thead>
              <tr>
                <th>Step</th>
                <th>Original (X)</th>
                <th>Extract Digit</th>
                <th>Reversed (N)</th>
                <th>Operation on N</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Start</td>
                <td>5461</td>
                <td>-</td>
                <td>0</td>
                <td>-</td>
              </tr>
              <tr>
                <td>1</td>
                <td>5461</td>
                <td>1</td>
                <td>0 √ó 10 + 1 = 1</td>
                <td>Shift and add</td>
              </tr>
              <tr>
                <td>2</td>
                <td>546</td>
                <td>6</td>
                <td>1 √ó 10 + 6 = 16</td>
                <td>Shift and add</td>
              </tr>
              <tr>
                <td>3</td>
                <td>54</td>
                <td>4</td>
                <td>16 √ó 10 + 4 = 164</td>
                <td>Shift and add</td>
              </tr>
              <tr>
                <td>4</td>
                <td>5</td>
                <td>5</td>
                <td>164 √ó 10 + 5 = 1645</td>
                <td>Shift and add</td>
              </tr>
              <tr>
                <td>End</td>
                <td>0</td>
                <td>-</td>
                <td><strong>1645</strong></td>
                <td>Done!</td>
              </tr>
            </tbody>
          </table>
        </div>

        <h3>Key Operations</h3>

        <div class="highlight">
          <p><strong>Two Critical Operations:</strong></p>
          <ol>
            <li>
              <strong>Extract unit digit:</strong> Use modulo operation (X % 10)
            </li>
            <li>
              <strong>Shift left and add:</strong> Multiply by 10 and add new
              digit (N √ó 10 + digit)
            </li>
          </ol>
        </div>

        <h3>Flowchart Representation</h3>

        <div class="flowchart-box">
          <p><strong>START</strong></p>
          <p>‚Üì</p>
          <p>Initialize: N = 0 (reversed number), X = input number</p>
          <p>‚Üì</p>
          <p>Is X == 0?</p>
          <p>No ‚Üí Continue | Yes ‚Üí Print N and END</p>
          <p>‚Üì</p>
          <p>Extract unit digit: digit = X % 10</p>
          <p>‚Üì</p>
          <p>Shift and store: N = N √ó 10 + digit</p>
          <p>‚Üì</p>
          <p>Remove last digit: X = X √∑ 10</p>
          <p>‚Üì</p>
          <p>Go back to "Is X == 0?"</p>
        </div>

        <div class="professor-note">
          Drawing flowcharts is one of the simplest and easiest ways to
          represent your computational thought process. It shows the
          step-by-step thinking clearly. I strongly encourage you to draw lots
          of flowcharts in your notebook for practice problems!
        </div>

        <h3>Detailed Algorithm Steps</h3>

        <pre class="code-block"><code>ALGORITHM: Reverse a Number

1. START
2. Initialize variables:
    - N = 0 (reversed number)
    - X = input number
3. WHILE X ‚â† 0:
    a. digit = X % 10 (extract last digit)
    b. N = N √ó 10 + digit (shift left and add)
    c. X = X √∑ 10 (integer division - remove last digit)
4. PRINT N
5. END
</code></pre>

        <h3>Verification</h3>

        <div class="professor-note">
          After designing an algorithm, it's very important to verify it! Take
          sample numbers and manually go through each step, applying the
          operations. This helps you confirm whether your solution is correct or
          if modifications are needed.
        </div>

        <div class="example-box">
          <h4>Try verifying with these test cases:</h4>
          <ul>
            <li>Input: 123 ‚Üí Expected Output: 321</li>
            <li>Input: 1000 ‚Üí Expected Output: 0001 = 1</li>
            <li>Input: 9 ‚Üí Expected Output: 9</li>
          </ul>
        </div>

        <div class="key-takeaways">
          <h4>üîë Key Takeaways</h4>
          <ul>
            <li>
              Number reversal uses digit extraction and "shift-and-add"
              technique
            </li>
            <li>Flowcharts effectively visualize computational processes</li>
            <li>Always verify your algorithm with multiple test cases</li>
            <li>Practice drawing flowcharts to improve algorithmic thinking</li>
            <li>Same termination condition: continue while number ‚â† 0</li>
          </ul>
        </div>

        <div class="hinglish-summary">
          <h4>üìù Hinglish Summary</h4>
          <p>
            Number reverse karne ke liye: last digit nikalo (modulo % 10 se),
            usko naye number mein store karo (multiply by 10 karke add karo),
            aur original number se wo digit hatao (divide by 10). Ye process tab
            tak repeat karo jab tak original number 0 nahi ho jata. Flowchart
            banana process ko visualize karne ka best tarika hai. Algorithm
            design karne ke baad multiple test cases se verify karna mat bhoolo!
          </p>
        </div>
      </section>

      <!-- Section 9: Flowcharts -->
      <section id="flowcharts">
        <h2>9. Flowcharts and Computational Thinking</h2>

        <p>
          Flowcharts are visual representations of algorithms that use
          standardized symbols to show the flow of control and operations in a
          step-by-step manner.
        </p>

        <h3>Why Use Flowcharts?</h3>

        <ul>
          <li>
            <strong>Visual Clarity:</strong> Makes logic easy to understand at a
            glance
          </li>
          <li>
            <strong>Error Detection:</strong> Helps identify logical flaws
            before coding
          </li>
          <li>
            <strong>Communication:</strong> Universal language for describing
            algorithms
          </li>
          <li>
            <strong>Documentation:</strong> Serves as reference for future
            modifications
          </li>
          <li>
            <strong>Planning Tool:</strong> Helps organize thoughts before
            writing code
          </li>
        </ul>

        <h3>Standard Flowchart Symbols</h3>

        <table>
          <thead>
            <tr>
              <th>Symbol</th>
              <th>Name</th>
              <th>Purpose</th>
              <th>Example</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>‚¨≠ (Oval)</td>
              <td>Terminal</td>
              <td>Start/End of algorithm</td>
              <td>START, END</td>
            </tr>
            <tr>
              <td>‚ñ≠ (Rectangle)</td>
              <td>Process</td>
              <td>Computation or operation</td>
              <td>sum = sum + 10</td>
            </tr>
            <tr>
              <td>‚ñ± (Parallelogram)</td>
              <td>Input/Output</td>
              <td>Data input or output</td>
              <td>Read X, Print result</td>
            </tr>
            <tr>
              <td>‚óá (Diamond)</td>
              <td>Decision</td>
              <td>Conditional branching</td>
              <td>Is X > 0?</td>
            </tr>
            <tr>
              <td>‚Üí (Arrow)</td>
              <td>Flow Line</td>
              <td>Direction of flow</td>
              <td>Connects symbols</td>
            </tr>
          </tbody>
        </table>

        <h3>Best Practices for Drawing Flowcharts</h3>

        <div class="example-box">
          <h4>DO's:</h4>
          <ul>
            <li>‚úì Use standard symbols consistently</li>
            <li>‚úì Keep flow top-to-bottom or left-to-right</li>
            <li>‚úì Label decision branches clearly (Yes/No, True/False)</li>
            <li>‚úì Keep it simple and readable</li>
            <li>‚úì Test your flowchart with sample data</li>
          </ul>
        </div>

        <div class="example-box">
          <h4>DON'Ts:</h4>
          <ul>
            <li>‚úó Don't cross flow lines unnecessarily</li>
            <li>‚úó Don't use ambiguous labels</li>
            <li>‚úó Don't make it too complex in one diagram</li>
            <li>‚úó Don't forget START and END terminals</li>
          </ul>
        </div>

        <h3>Practice Exercise</h3>

        <div class="professor-note">
          I strongly encourage you to take more problems from the textbook and
          lab exercises, and draw lots of flowcharts. Practice in your notebook
          with pen and paper. The more you draw, the better you'll understand
          the computational process. Try to see if you can reduce the number of
          steps or merge operations to optimize your solutions!
        </div>

        <div class="diagram-placeholder">
          [Insert diagram: Example flowchart showing a complete problem solution
          with all standard symbols properly connected]
        </div>

        <div class="key-takeaways">
          <h4>üîë Key Takeaways</h4>
          <ul>
            <li>Flowcharts provide visual representation of algorithms</li>
            <li>Standard symbols ensure universal understanding</li>
            <li>Drawing flowcharts helps identify logic errors early</li>
            <li>Practice is essential to master flowchart design</li>
            <li>Always verify flowcharts with test data before coding</li>
          </ul>
        </div>

        <div class="hinglish-summary">
          <h4>üìù Hinglish Summary</h4>
          <p>
            Flowchart ek visual tool hai jo algorithm ko step-by-step dikhata
            hai. Isme standard symbols use hote hain - oval (start/end),
            rectangle (process), parallelogram (input/output), diamond
            (decision). Flowchart banana coding se pehle logic ko clear karne ka
            best tarika hai. Practice zaroori hai - jitna zyada notebook mein
            flowcharts banao, utna better understanding hoga. Hamesha sample
            data se verify karo ki flowchart sahi kaam kar raha hai ya nahi.
          </p>
        </div>
      </section>

      <!-- Section 10: Pseudocode -->
      <section id="pseudocode">
        <h2>10. Introduction to Pseudocode</h2>

        <p>
          <strong>Pseudocode</strong> is a way of writing algorithms that
          resembles actual programming code but uses plain English-like
          statements instead of strict programming syntax.
        </p>

        <h3>Understanding Pseudocode</h3>

        <div class="highlight">
          <p><strong>Etymology:</strong></p>
          <ul>
            <li>
              <strong>"Code"</strong> = Programs (instructions for computers)
            </li>
            <li><strong>"Pseudo"</strong> = False, not real, resembling</li>
            <li>
              <strong>"Pseudocode"</strong> = Looks like code but isn't actual
              executable code
            </li>
          </ul>
        </div>

        <div class="professor-note">
          Pseudocode looks very much like actual code, but if you copy-paste it
          into a computer, the computer may not understand it directly. However,
          for OUR purposes - for human understanding - pseudocode is perfect
          because it bridges the gap between flowcharts and real programming
          code.
        </div>

        <h3>Pseudocode vs. Real Code vs. Flowcharts</h3>

        <table>
          <thead>
            <tr>
              <th>Aspect</th>
              <th>Flowchart</th>
              <th>Pseudocode</th>
              <th>Real Code</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Format</strong></td>
              <td>Visual diagrams</td>
              <td>Text (code-like)</td>
              <td>Strict syntax</td>
            </tr>
            <tr>
              <td><strong>Rules</strong></td>
              <td>Standard symbols</td>
              <td>Flexible, no strict rules</td>
              <td>Must follow language syntax</td>
            </tr>
            <tr>
              <td><strong>Executable?</strong></td>
              <td>No</td>
              <td>No</td>
              <td>Yes</td>
            </tr>
            <tr>
              <td><strong>Purpose</strong></td>
              <td>Visualize logic flow</td>
              <td>Bridge design and implementation</td>
              <td>Computer execution</td>
            </tr>
            <tr>
              <td><strong>Audience</strong></td>
              <td>Anyone (universal)</td>
              <td>Programmers/designers</td>
              <td>Computers/compilers</td>
            </tr>
          </tbody>
        </table>

        <h3>From Flowchart to Pseudocode</h3>

        <p>The natural progression in algorithm design:</p>

        <div class="flowchart-box">
          <p><strong>Problem Statement</strong></p>
          <p>‚Üì</p>
          <p><strong>Flowchart</strong> (Visual representation)</p>
          <p>‚Üì</p>
          <p><strong>Pseudocode</strong> (Text-based, code-like)</p>
          <p>‚Üì</p>
          <p><strong>Real Code</strong> (Programming language)</p>
        </div>

        <h3>Programming Languages</h3>

        <div class="highlight">
          <p><strong>What are Programming Languages?</strong></p>
          <p>
            Programming languages are formal languages with specific sets of
            rules and regulations that you must follow to create code that
            computers can understand and execute. They provide syntax (grammar
            rules) and semantics (meaning) for writing programs.
          </p>
        </div>

        <div class="professor-note">
          Programs are like speeches you design for talking to the computer.
          It's a way to communicate with the computer, to tell it "do this, do
          that, do this, do that." Programming languages give you the structure
          and vocabulary to have this conversation effectively.
        </div>

        <h3>Example: Same Algorithm in Different Forms</h3>

        <div class="example-box">
          <h4>Problem: Add two numbers</h4>

          <p><strong>In Flowchart:</strong></p>
          <div class="diagram-placeholder">
            [START] ‚Üí [Input A, B] ‚Üí [sum = A + B] ‚Üí [Print sum] ‚Üí [END]
          </div>

          <p><strong>In Pseudocode:</strong></p>
          <div class="code-block">
            BEGIN INPUT A, B sum = A + B PRINT sum END
          </div>

          <p><strong>In Python (Real Code):</strong></p>
          <div class="code-block">
            a = int(input("Enter first number: ")) b = int(input("Enter second
            number: ")) sum = a + b print("Sum is:", sum)
          </div>
        </div>

        <h3>Advantages of Pseudocode</h3>

        <ul>
          <li>
            <strong>No syntax constraints:</strong> Focus on logic, not language
            rules
          </li>
          <li><strong>Easy to modify:</strong> Changes are quick and simple</li>
          <li>
            <strong>Language-independent:</strong> Can translate to any
            programming language
          </li>
          <li><strong>Readable:</strong> Anyone can understand the logic</li>
          <li>
            <strong>Speeds up development:</strong> Plan before coding reduces
            errors
          </li>
        </ul>

        <div class="key-takeaways">
          <h4>üîë Key Takeaways</h4>
          <ul>
            <li>Pseudocode bridges flowcharts and real programming code</li>
            <li>It looks like code but doesn't follow strict syntax rules</li>
            <li>
              Programming languages have specific rules that must be followed
            </li>
            <li>Pseudocode is language-independent and focuses on logic</li>
            <li>The progression: Problem ‚Üí Flowchart ‚Üí Pseudocode ‚Üí Code</li>
          </ul>
        </div>

        <div class="hinglish-summary">
          <h4>üìù Hinglish Summary</h4>
          <p>
            Pseudocode ek tarika hai algorithm likhne ka jo code jaisa dikhta
            hai lekin actual programming language nahi hai. Iska matlab hai
            "fake code" - asli code jaisa lagta hai par computer directly
            execute nahi kar sakta. Ye flowchart aur real code ke beech ka
            bridge hai. Programming languages mein strict rules hote hain jo
            follow karne zaroori hain, lekin pseudocode flexible hai - sirf
            logic pe focus karo, syntax ki tension nahi. Ye language-independent
            hai, matlab kisi bhi programming language mein convert kar sakte ho.
          </p>
        </div>
      </section>

      <!-- Section 11: Class Average Example -->
      <section id="class-average">
        <h2>11. Detailed Example: Computing Class Average</h2>

        <p>
          Let's work through a comprehensive example that demonstrates the
          complete stepwise refinement process: computing the average marks of a
          class.
        </p>

        <h3>Problem Statement</h3>

        <div class="example-box">
          <h4>Original Problem:</h4>
          <p>
            Determine the class average for a set of test marks input by the
            user. The number of test marks is not known in advance, so the user
            will enter a special code (a "sentinel" value) to indicate they're
            finished entering grades.
          </p>
        </div>

        <h3>Step 1: Identify Inputs and Outputs</h3>

        <div class="professor-note">
          When you start solving any problem, the FIRST thing you must think
          about is: What are my inputs? What are my outputs? This is the most
          important first step!
        </div>

        <table>
          <thead>
            <tr>
              <th>Category</th>
              <th>Details</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Inputs</strong></td>
              <td>
                ‚Ä¢ Number of students (unknown in advance)<br />
                ‚Ä¢ Marks of each student (one at a time)<br />
                ‚Ä¢ Sentinel value to indicate end (-1)
              </td>
            </tr>
            <tr>
              <td><strong>Output</strong></td>
              <td>‚Ä¢ Class average</td>
            </tr>
            <tr>
              <td><strong>Constraints</strong></td>
              <td>
                ‚Ä¢ Marks range: 0 to 100<br />
                ‚Ä¢ Sentinel value: -1 (outside valid range)
              </td>
            </tr>
          </tbody>
        </table>

        <h3>Step 2: First Level Decomposition</h3>

        <p>Break the problem into broad steps:</p>

        <div class="code-block">
          LEVEL 1 DECOMPOSITION: 1. Declare and initialize variables 2. Input
          marks (prompt user and allow input) 3. Compute class average and
          output result
        </div>

        <div class="professor-note">
          Notice how these three steps are very broad. There's a lot of detail
          that's abstracted (hidden). For example: Where's the stopping
          character check? How do we compute the average? Where do we print? All
          these details will come in the next refinement.
        </div>

        <h3>Step 3: Refining the "Compute" Step</h3>

        <div class="highlight">
          <p>The "Compute class average" step can be broken down into:</p>
          <ol>
            <li><strong>Add the marks</strong> (maintain running sum)</li>
            <li><strong>Count the marks</strong> (track how many entered)</li>
            <li><strong>Divide sum by count</strong> (calculate average)</li>
          </ol>
        </div>

        <div class="code-block">
          REVISED LEVEL 1 DECOMPOSITION: 1. Declare and initialize variables 2.
          Input marks - count and add them as they are input 3. Compute class
          average (sum √∑ count) 4. Print result
        </div>

        <h3>Step 4: Refining the "Input" Step (Level 2)</h3>

        <p>The input step needs more detail:</p>

        <div class="code-block">
          LEVEL 2 - INPUT STEP BREAKDOWN: Loop until user enters sentinel value
          (-1): 1. Prompt user to enter a mark (tell them -1 to quit) 2. Allow
          user to type in a mark (store in variable) 3. Add the mark into sum
          variable 4. Add 1 to counter (track how many marks)
        </div>

        <div class="professor-note">
          We're using -1 as the sentinel value because marks range from 0 to
          100. So -1 is a safe choice - it's impossible to get -1 as an actual
          mark. Choosing good sentinel values is important!
        </div>

        <h3>Step 5: Further Refinement - Adding Conditions</h3>

        <div class="highlight">
          <p>
            <strong>Problem Identified:</strong> We're adding and counting even
            the sentinel value! We need to check if the entered value is
            actually a mark before processing it.
          </p>
        </div>

        <div class="code-block">
          REFINED INPUT STEP: DO: Prompt user to enter a mark Allow user to type
          in a mark IF the entered value is a MARK (not sentinel): Add the mark
          to sum Add 1 to counter WHILE user has NOT entered sentinel value
        </div>

        <h3>Step 6: Identifying All Variables</h3>

        <div class="example-box">
          <h4>Variables Needed:</h4>
          <table>
            <thead>
              <tr>
                <th>Variable</th>
                <th>Purpose</th>
                <th>Initial Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>mark</strong></td>
                <td>Store each user-entered mark</td>
                <td>No initialization needed</td>
              </tr>
              <tr>
                <td><strong>sum</strong></td>
                <td>Accumulate total of all marks</td>
                <td><strong>0</strong> (must initialize!)</td>
              </tr>
              <tr>
                <td><strong>counter</strong></td>
                <td>Count how many marks entered</td>
                <td><strong>0</strong> (must initialize!)</td>
              </tr>
              <tr>
                <td><strong>average</strong></td>
                <td>Store final result (optional)</td>
                <td>Not needed (can print directly)</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="professor-note">
          Notice that we don't really need a separate variable for average. We
          can directly print the division result: sum √∑ counter. If a variable
          is avoidable, don't use it! Keep your solution simple.
        </div>

        <h3>Step 7: Complete Pseudocode</h3>

        <div class="code-block">
          ALGORITHM: Compute Class Average 1. START 2. Initialize variables: sum
          = 0 counter = 0 3. Grade entry loop: DO: PRINT "Enter a mark (-1 to
          quit): " INPUT mark IF mark is not equal to -1: sum = sum + mark
          counter = counter + 1 END IF WHILE mark is not equal to -1 4. Compute
          and display average: average = sum √∑ counter PRINT "Class average
          is:", average 5. END
        </div>

        <h3>Step 8: Verification</h3>

        <div class="example-box">
          <h4>Test Case 1:</h4>
          <p><strong>Input marks:</strong> 80, 90, 70, -1</p>
          <table>
            <thead>
              <tr>
                <th>Iteration</th>
                <th>mark</th>
                <th>sum</th>
                <th>counter</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Initial</td>
                <td>-</td>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <td>1</td>
                <td>80</td>
                <td>0 + 80 = 80</td>
                <td>0 + 1 = 1</td>
              </tr>
              <tr>
                <td>2</td>
                <td>90</td>
                <td>80 + 90 = 170</td>
                <td>1 + 1 = 2</td>
              </tr>
              <tr>
                <td>3</td>
                <td>70</td>
                <td>170 + 70 = 240</td>
                <td>2 + 1 = 3</td>
              </tr>
              <tr>
                <td>4</td>
                <td>-1</td>
                <td>240 (no change)</td>
                <td>3 (no change)</td>
              </tr>
              <tr>
                <td><strong>Result</strong></td>
                <td colspan="3"><strong>Average = 240 √∑ 3 = 80</strong> ‚úì</td>
              </tr>
            </tbody>
          </table>
        </div>

        <h3>Key Concepts Demonstrated</h3>

        <ul>
          <li>
            <strong>Sentinel Value:</strong> Special value indicating end of
            input
          </li>
          <li><strong>Running Sum:</strong> Accumulating total as we go</li>
          <li>
            <strong>Counter Pattern:</strong> Tracking number of iterations
          </li>
          <li>
            <strong>Conditional Processing:</strong> Only process valid marks
          </li>
          <li>
            <strong>Loop-Until-Sentinel:</strong> Continue until special value
            appears
          </li>
        </ul>

        <div class="practice-questions">
          <h4>üéØ Practice Questions</h4>

          <div class="question">
            <p>
              <strong>Q1:</strong> What would happen if we forgot to initialize
              sum = 0?
            </p>
            <div class="answer">
              <p>
                <strong>Answer:</strong> The sum variable would contain a
                garbage (random) value. When we add marks to it, we'd get
                incorrect results. For example, if garbage value was 547, and
                marks were 80, 90, 70, we'd get: 547 + 80 + 90 + 70 = 787
                instead of 240. Always initialize!
              </p>
            </div>
          </div>

          <div class="question">
            <p>
              <strong>Q2:</strong> Why can't we use 0 or 100 as sentinel values?
            </p>
            <div class="answer">
              <p>
                <strong>Answer:</strong> Because 0 and 100 are valid marks! A
                student could score 0 (fail) or 100 (perfect). If we used 0 as
                sentinel, we couldn't record students who scored 0. The sentinel
                value must be outside the valid range of inputs.
              </p>
            </div>
          </div>

          <div class="question">
            <p>
              <strong>Q3:</strong> What if counter ends up being 0 (no marks
              entered)?
            </p>
            <div class="answer">
              <p>
                <strong>Answer:</strong> We'd have a division-by-zero error!
                (sum √∑ 0 is undefined). A complete solution should check: IF
                counter > 0 THEN calculate average ELSE print "No marks
                entered".
              </p>
            </div>
          </div>
        </div>

        <div class="key-takeaways">
          <h4>üîë Key Takeaways</h4>
          <ul>
            <li>Always start by identifying inputs and outputs clearly</li>
            <li>Use stepwise refinement to progressively add detail</li>
            <li>Sentinel values enable unknown-length input sequences</li>
            <li>Always initialize accumulator variables (sum, counter) to 0</li>
            <li>Verify your algorithm with test cases before coding</li>
            <li>Consider edge cases (like zero marks entered)</li>
          </ul>
        </div>

        <div class="hinglish-summary">
          <h4>üìù Hinglish Summary</h4>
          <p>
            Class average calculate karne ke liye pehle inputs-outputs identify
            karo: marks input (number unknown), class average output. Sentinel
            value (-1) use karo to signal end of input. Teen variables chahiye -
            sum (total marks, initialize = 0), counter (kitne marks, initialize
            = 0), aur mark (current input). Loop chalao jab tak sentinel nahi
            aata: mark input lo, valid hai toh sum mein add karo aur counter
            increase karo. End mein sum √∑ counter se average nikalo. Hamesha
            initialization karo warna garbage values se wrong answer aayega.
            Test cases se verify karo - edge cases bhi check karo jaise zero
            marks entered.
          </p>
        </div>
      </section>

      <!-- Section 12: Parking Lot Example -->
      <section id="parking-lot">
        <h2>12. Example: Parking Lot Program</h2>

        <p>
          Let's apply stepwise refinement to another practical problem:
          computing bills for a parking lot.
        </p>

        <h3>Problem Statement</h3>

        <div class="example-box">
          <h4>Parking Lot Billing System:</h4>
          <p>
            Design a program that computes the parking bill for cars based on
            their entry time, exit time, and hourly rates.
          </p>
        </div>

        <h3>Level 1: Initial Decomposition</h3>

        <div class="code-block">
          HIGH-LEVEL STEPS: 1. Get Input Data 2. Compute Bill 3. Print Bill
        </div>

        <h3>Level 2: Refined Decomposition</h3>

        <table>
          <thead>
            <tr>
              <th>Main Step</th>
              <th>Sub-steps</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>1. Get Input Data</strong></td>
              <td>
                ‚Ä¢ Get entry time<br />
                ‚Ä¢ Get exit time<br />
                ‚Ä¢ Get hourly rate (possibly variable)
              </td>
            </tr>
            <tr>
              <td><strong>2. Compute Bill</strong></td>
              <td>
                ‚Ä¢ Find duration (exit time - entry time)<br />
                ‚Ä¢ Compute amount due based on hourly rate<br />
                ‚Ä¢ Apply any special rates (night, 24-hour, etc.)
              </td>
            </tr>
            <tr>
              <td><strong>3. Print Bill</strong></td>
              <td>
                ‚Ä¢ Print company logo<br />
                ‚Ä¢ Print entry and exit times<br />
                ‚Ä¢ Print amount due
              </td>
            </tr>
          </tbody>
        </table>

        <div class="professor-note">
          This decomposition may seem trivial or extremely simple, but these are
          the basic techniques you need to develop. Don't think this is the ONLY
          way to solve it - there might be 5 different ways! Think about how YOU
          might reduce steps or make them more explicit.
        </div>

        <h3>Important Considerations</h3>

        <div class="highlight">
          <p><strong>What's Missing?</strong></p>
          <p>
            Notice that the hourly rate input is not explicitly shown in the
            basic decomposition. In real parking lots:
          </p>
          <ul>
            <li>Morning rates might be different from evening rates</li>
            <li>Night parking has different rates</li>
            <li>24-hour parking has flat rates</li>
            <li>Weekend vs. weekday rates may differ</li>
          </ul>
          <p>These details would need to be added in further refinements!</p>
        </div>

        <h3>Variables Needed</h3>

        <table>
          <thead>
            <tr>
              <th>Variable</th>
              <th>Type</th>
              <th>Purpose</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>entryTime</strong></td>
              <td>Time/String</td>
              <td>When car entered</td>
            </tr>
            <tr>
              <td><strong>exitTime</strong></td>
              <td>Time/String</td>
              <td>When car left</td>
            </tr>
            <tr>
              <td><strong>duration</strong></td>
              <td>Number</td>
              <td>Hours parked</td>
            </tr>
            <tr>
              <td><strong>hourlyRate</strong></td>
              <td>Number</td>
              <td>Cost per hour</td>
            </tr>
            <tr>
              <td><strong>amountDue</strong></td>
              <td>Number</td>
              <td>Total bill</td>
            </tr>
          </tbody>
        </table>

        <h3>Pseudocode Outline</h3>

        <div class="code-block">
          ALGORITHM: Parking Lot Billing 1. START 2. Display company logo and
          welcome message 3. Input Phase: PRINT "Enter entry time (HH:MM): "
          INPUT entryTime PRINT "Enter exit time (HH:MM): " INPUT exitTime PRINT
          "Enter hourly rate: " INPUT hourlyRate 4. Computation Phase: duration
          = exitTime - entryTime // Calculate hours amountDue = duration √ó
          hourlyRate 5. Output Phase: PRINT "========== PARKING RECEIPT
          ==========" PRINT "Entry Time:", entryTime PRINT "Exit Time:",
          exitTime PRINT "Duration:", duration, "hours" PRINT "Rate: $",
          hourlyRate, "per hour" PRINT "Amount Due: $", amountDue PRINT
          "====================================" 6. END
        </div>

        <h3>Exercise for You</h3>

        <div class="practice-questions">
          <h4>üéØ Think About These Questions</h4>

          <div class="question">
            <p>
              <strong>Q1:</strong> What other inputs might be critical that
              aren't shown in this basic solution?
            </p>
            <div class="answer">
              <p><strong>Possible Additional Inputs:</strong></p>
              <ul>
                <li>Vehicle type (car, bike, truck) - different rates</li>
                <li>Parking zone/location - premium vs regular</li>
                <li>Day type (weekday/weekend)</li>
                <li>Membership status (discounts for members)</li>
                <li>Vehicle registration number for tracking</li>
              </ul>
            </div>
          </div>

          <div class="question">
            <p>
              <strong>Q2:</strong> How would you handle partial hours? (e.g.,
              2.5 hours)
            </p>
            <div class="answer">
              <p><strong>Answer:</strong> You could:</p>
              <ul>
                <li>Round up to next full hour (2.5 becomes 3)</li>
                <li>Charge proportionally (2.5 hours = 2.5 √ó rate)</li>
                <li>Have minimum billing units (round to nearest 15 mins)</li>
              </ul>
              <p>
                This decision affects the "Compute Bill" step and needs
                clarification!
              </p>
            </div>
          </div>
        </div>

        <div class="key-takeaways">
          <h4>üîë Key Takeaways</h4>
          <ul>
            <li>Stepwise refinement works for any real-world problem</li>
            <li>Initial decompositions are deliberately abstract</li>
            <li>Missing details become apparent during refinement</li>
            <li>Always question: "What else might be needed?"</li>
            <li>
              Different solutions are possible - there's no single "correct" way
            </li>
          </ul>
        </div>

        <div class="hinglish-summary">
          <h4>üìù Hinglish Summary</h4>
          <p>
            Parking lot billing program mein teen main steps hain - input lo,
            bill calculate karo, print karo. Input mein entry time, exit time
            aur hourly rate chahiye. Computation mein duration nikalo (exit -
            entry) aur amount calculate karo (duration √ó rate). Output mein
            receipt print karo with all details. Real-world mein aur bhi
            cheezein consider karni padti hain jaise variable rates
            (morning/night), vehicle types, partial hours billing etc. Ye basic
            decomposition hai - aap isko aur refine kar sakte ho apni zaroorat
            ke hisaab se.
          </p>
        </div>
      </section>

      <!-- Section 13: Practice Questions -->
      <section id="practice">
        <h2>13. Practice Questions</h2>

        <div class="practice-questions">
          <h4>üéØ Quiz: Minimum Steps Required</h4>

          <div class="question">
            <p>
              <strong>Question:</strong> What is the minimum number of steps
              required to find the sum and product of two given numbers?
            </p>
            <p><strong>Options:</strong></p>
            <ul>
              <li>A) 1</li>
              <li>B) 3</li>
              <li>C) 4</li>
              <li>D) 5</li>
            </ul>
            <div class="answer">
              <p><strong>Correct Answer: D) 5</strong></p>
              <p><strong>Explanation:</strong></p>
              <ol>
                <li>START</li>
                <li>INPUT two numbers (A and B)</li>
                <li>Compute sum = A + B</li>
                <li>Compute product = A √ó B</li>
                <li>OUTPUT sum and product / END</li>
              </ol>
              <p>
                We need START and END terminals, input step, two computation
                steps, and output step = minimum 5 steps.
              </p>
            </div>
          </div>

          <h4>üéØ Comprehensive Practice Problems</h4>

          <div class="question">
            <p>
              <strong>Problem 1:</strong> Design an algorithm to find the
              largest of three numbers.
            </p>
            <div class="answer">
              <p><strong>Solution Approach:</strong></p>
              <div class="code-block">
                ALGORITHM: Find Largest of Three Numbers 1. START 2. INPUT A, B,
                C 3. IF A > B AND A > C: largest = A ELSE IF B > A AND B > C:
                largest = B ELSE: largest = C 4. PRINT "Largest is:", largest 5.
                END Variables needed: A, B, C, largest
              </div>
            </div>
          </div>

          <div class="question">
            <p>
              <strong>Problem 2:</strong> Create a flowchart and pseudocode to
              check if a number is even or odd.
            </p>
            <div class="answer">
              <p><strong>Solution:</strong></p>
              <div class="code-block">
                ALGORITHM: Check Even or Odd 1. START 2. INPUT number N 3.
                remainder = N % 2 4. IF remainder == 0: PRINT "Even" ELSE: PRINT
                "Odd" 5. END Key concept: Use modulo operator (%) to find
                remainder If N % 2 == 0, number is even If N % 2 == 1, number is
                odd
              </div>
            </div>
          </div>

          <div class="question">
            <p>
              <strong>Problem 3:</strong> Design an algorithm to calculate
              factorial of a number.
            </p>
            <div class="answer">
              <p><strong>Solution with stepwise refinement:</strong></p>
              <div class="code-block">
                ALGORITHM: Calculate Factorial 1. START 2. INPUT N 3. Initialize
                factorial = 1 4. Initialize counter = 1 5. WHILE counter <= N:
                factorial = factorial √ó counter counter = counter + 1 6. PRINT
                "Factorial of", N, "is", factorial 7. END Example: N = 5
                factorial = 1 √ó 1 √ó 2 √ó 3 √ó 4 √ó 5 = 120 Variables: N, factorial
                (init=1), counter (init=1)
              </div>
            </div>
          </div>

          <div class="question">
            <p>
              <strong>Problem 4:</strong> Write pseudocode to find sum of first
              N natural numbers.
            </p>
            <div class="answer">
              <p><strong>Two approaches:</strong></p>
              <div class="code-block">
                APPROACH 1: Using Loop 1. INPUT N 2. sum = 0 3. counter = 1 4.
                WHILE counter <= N: sum = sum + counter counter = counter + 1 5.
                PRINT sum APPROACH 2: Using Formula 1. INPUT N 2. sum = N √ó (N +
                1) / 2 3. PRINT sum Both give same result, but Approach 2 is
                more efficient! For N = 10: sum = 10 √ó 11 / 2 = 55
              </div>
            </div>
          </div>

          <div class="question">
            <p>
              <strong>Problem 5:</strong> Design an algorithm to check if a
              number is prime.
            </p>
            <div class="answer">
              <p><strong>Solution:</strong></p>
              <div class="code-block">
                ALGORITHM: Check Prime Number 1. START 2. INPUT N 3. IF N <= 1:
                PRINT "Not prime" STOP 4. isPrime = TRUE 5. divisor = 2 6. WHILE
                divisor <= N/2: IF N % divisor == 0: isPrime = FALSE BREAK
                divisor = divisor + 1 7. IF isPrime == TRUE: PRINT "Prime" ELSE:
                PRINT "Not prime" 8. END Logic: A number is prime if it's only
                divisible by 1 and itself Check divisibility from 2 to N/2 If
                any divisor found, it's not prime
              </div>
            </div>
          </div>
        </div>

        <div class="key-takeaways">
          <h4>üîë Practice Tips</h4>
          <ul>
            <li>Start every solution by identifying inputs and outputs</li>
            <li>Draw flowcharts first for visual clarity</li>
            <li>Write pseudocode before actual coding</li>
            <li>Always test with multiple examples</li>
            <li>Consider edge cases (zero, negative, very large numbers)</li>
            <li>Look for optimization opportunities after first solution</li>
          </ul>
        </div>

        <div class="hinglish-summary">
          <h4>üìù Hinglish Summary</h4>
          <p>
            Practice problems solve karne ke liye systematic approach follow
            karo: pehle inputs-outputs identify karo, phir flowchart banao, uske
            baad pseudocode likho, aur finally actual code mein convert karo.
            Har problem ke multiple solutions ho sakte hain - kuch simple but
            slow, kuch complex but fast. Hamesha edge cases test karo jaise
            zero, negative numbers, very large values. Practice se hi perfection
            aayega - jitna zyada practice, utna better algorithmic thinking!
          </p>
        </div>
      </section>

      <!-- Section 14: Mind Map -->
      <section id="mind-map">
        <div class="mind-map">
          <h2>14. Comprehensive Mind Map</h2>

          <div class="mind-map-container">
            <div class="mind-map-node">
              <h3>üéØ Problem-Solving Process</h3>
              <ul>
                <li>Problem Analysis</li>
                <li>Alternative Consideration</li>
                <li>Choosing Approach</li>
                <li>Problem Decomposition</li>
                <li>Algorithm Development</li>
                <li>Correctness Verification</li>
                <li>Efficiency Analysis</li>
                <li>Reflection & Improvement</li>
              </ul>
            </div>

            <div class="mind-map-node">
              <h3>üìä Problem Understanding</h3>
              <ul>
                <li>Identify Input Categories</li>
                <li>Identify Output Requirements</li>
                <li>Determine Constraints</li>
                <li>Consider Edge Cases</li>
                <li>Each Input as Subtask</li>
                <li>Input-Process-Output Model</li>
              </ul>
            </div>

            <div class="mind-map-node">
              <h3>üì¶ Variables</h3>
              <ul>
                <li>Box with Tag Analogy</li>
                <li>Memory Locations (Fixed)</li>
                <li>Variable Names (Movable)</li>
                <li>Limited Size (Bounded)</li>
                <li>Single Value at a Time</li>
                <li>Initialization Required</li>
                <li>Data Types Matter</li>
              </ul>
            </div>

            <div class="mind-map-node">
              <h3>üîÑ Stepwise Refinement</h3>
              <ul>
                <li>Top-Down Methodology</li>
                <li>Progressive Detail Addition</li>
                <li>Start with Broad Steps</li>
                <li>Refine Iteratively</li>
                <li>Data Structure Impact</li>
                <li>Niklaus Wirth (1971)</li>
                <li>Task & Data Decomposition</li>
              </ul>
            </div>

            <div class="mind-map-node">
              <h3>üìà Flowcharts</h3>
              <ul>
                <li>Visual Representation</li>
                <li>Standard Symbols</li>
                <li>Terminal (Start/End)</li>
                <li>Process (Operations)</li>
                <li>Input/Output</li>
                <li>Decision (Conditionals)</li>
                <li>Flow Lines</li>
              </ul>
            </div>

            <div class="mind-map-node">
              <h3>üìù Pseudocode</h3>
              <ul>
                <li>Code-like but not Executable</li>
                <li>Language Independent</li>
                <li>Bridges Design & Implementation</li>
                <li>Flexible Syntax</li>
                <li>Human Readable</li>
                <li>Focus on Logic</li>
                <li>Easy to Modify</li>
              </ul>
            </div>

            <div class="mind-map-node">
              <h3>üíª Programming Languages</h3>
              <ul>
                <li>Formal Communication with Computer</li>
                <li>Strict Syntax Rules</li>
                <li>Grammar & Semantics</li>
                <li>Executable Code</li>
                <li>Python (Course Language)</li>
                <li>Code = Programs</li>
              </ul>
            </div>

            <div class="mind-map-node">
              <h3>üî¢ Digit Counting</h3>
              <ul>
                <li>Integer Division by 10</li>
                <li>Truncate Rightmost Digit</li>
                <li>Loop Until Zero</li>
                <li>Count Variable</li>
                <li>Finding Endpoint Challenge</li>
              </ul>
            </div>

            <div class="mind-map-node">
              <h3>üîÑ Number Reversal</h3>
              <ul>
                <li>Extract Unit Digit (% 10)</li>
                <li>Shift Left (* 10)</li>
                <li>Add New Digit</li>
                <li>Remove from Original (/ 10)</li>
                <li>Repeat Until Zero</li>
              </ul>
            </div>

            <div class="mind-map-node">
              <h3>üìä Class Average</h3>
              <ul>
                <li>Sentinel Value (-1)</li>
                <li>Running Sum</li>
                <li>Counter Pattern</li>
                <li>Initialize to Zero</li>
                <li>Divide Sum by Count</li>
                <li>Loop Until Sentinel</li>
                <li>Conditional Processing</li>
              </ul>
            </div>

            <div class="mind-map-node">
              <h3>üöó Parking Lot</h3>
              <ul>
                <li>Input: Entry/Exit Time</li>
                <li>Compute: Duration & Amount</li>
                <li>Output: Bill/Receipt</li>
                <li>Variable Rates Consideration</li>
                <li>Real-world Constraints</li>
              </ul>
            </div>

            <div class="mind-map-node">
              <h3>üéØ Key Principles</h3>
              <ul>
                <li>Practice Makes Perfect</li>
                <li>Multiple Solutions Possible</li>
                <li>Verify with Test Cases</li>
                <li>Consider Edge Cases</li>
                <li>Optimize After Correctness</li>
                <li>Clear Inputs/Outputs</li>
                <li>Iterative Refinement</li>
              </ul>
            </div>
          </div>
        </div>
      </section>

      <!-- Footer -->
      <div
        style="
          text-align: center;
          padding: 40px 20px;
          background: linear-gradient(135deg, #3c3c3c 0%, #565656 100%);
          color: white;
          border-radius: 10px;
          margin-top: 50px;
        "
      >
        <h3>
          I created this knowledge during my first semester of BSc in Applied AI
          and Data Science.
        </h3>
        <h3>~ Armaan Kachhawa</h3>
      </div>
    </div>
  </body>
</html>
