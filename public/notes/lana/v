"use client";

import { useState, useCallback, useMemo } from "react";
import { toast } from "sonner";
import { Loader2, RefreshCw, Copy, Zap, FileText, BarChart3 } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";

// Sample texts for quick testing
const SAMPLE_TEXTS = {
  "Business Email": "This email is to inform you that we have received your request and will be processing it accordingly. Please be advised that our team will review your submission and provide you with a comprehensive response within the designated timeframe.",
  "Blog Introduction": "In this comprehensive guide, we will explore the various methodologies and best practices that can be implemented to achieve optimal results in your endeavors. Through careful analysis and strategic implementation, you will be able to maximize your potential.",
  "Product Description": "This innovative solution provides users with advanced functionality and superior performance capabilities. The product features cutting-edge technology and has been designed to meet the highest standards of quality and reliability."
};

// Debounce hook
function useDebounce(callback, delay) {
  const [debounceTimer, setDebounceTimer] = useState(null);
  
  const debouncedCallback = useCallback((...args) => {
    if (debounceTimer) clearTimeout(debounceTimer);
    
    const newTimer = setTimeout(() => {
      callback(...args);
    }, delay);
    
    setDebounceTimer(newTimer);
  }, [callback, delay, debounceTimer]);
  
  return debouncedCallback;
}

// Text quality metrics calculator
function calculateMetrics(originalText, humanizedText) {
  if (!originalText || !humanizedText) return null;
  
  const originalWords = originalText.split(/\s+/).length;
  const humanizedWords = humanizedText.split(/\s+/).length;
  const lengthChange = ((humanizedWords - originalWords) / originalWords * 100).toFixed(1);
  
  // Simple readability score (Flesch-like)
  const avgWordsPerSentence = humanizedWords / (humanizedText.split(/[.!?]+/).length - 1);
  const readabilityScore = Math.max(0, Math.min(100, 100 - avgWordsPerSentence * 2)).toFixed(0);
  
  return {
    originalWords,
    humanizedWords,
    lengthChange,
    readabilityScore
  };
}

export function Agent() {
  const [input, setInput] = useState("");
  const [output, setOutput] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [progress, setProgress] = useState(0);
  const [activeTab, setActiveTab] = useState("input");

  // Calculate metrics
  const metrics = useMemo(() => calculateMetrics(input, output), [input, output]);

  // Debounced input handler
  const debouncedInputChange = useDebounce((value) => {
    // You could add auto-save or validation here
    console.log('Input changed:', value.length, 'characters');
  }, 500);

  const handleInputChange = (e) => {
    const value = e.target.value;
    setInput(value);
    debouncedInputChange(value);
  };

  const simulateProgress = () => {
    setProgress(0);
    const interval = setInterval(() => {
      setProgress(prev => {
        if (prev >= 90) {
          clearInterval(interval);
          return 90;
        }
        return prev + Math.random() * 15;
      });
    }, 500);
    return interval;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!input.trim()) {
      toast.warning("Please enter some text to humanize", {
        closeButton: true,
        duration: 3000,
      });
      return;
    }

    setIsLoading(true);
    const progressInterval = simulateProgress();

    try {
      const response = await fetch("/api/agent", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ input }),
      });

      clearInterval(progressInterval);
      setProgress(100);

      let data;
      const contentType = response.headers.get("content-type");
      if (contentType && contentType.includes("application/json")) {
        data = await response.json();
      } else {
        data = await response.text();
      }

      if (!response.ok) {
        const errorMessage = 
          typeof data === "object" && data.error 
            ? data.error 
            : `Error: ${response.status}`;
        throw new Error(errorMessage);
      }

      if (typeof data === "string") {
        setOutput(data);
      } else if (data && typeof data === "object") {
        setOutput(data.output || data.message || JSON.stringify(data));
      } else {
        setOutput(String(data));
      }

      setActiveTab("output");
      toast.success("Text humanized successfully!", {
        closeButton: true,
        duration: 3000,
      });
    } catch (error) {
      console.error("Error humanizing text:", error);
      toast.error(error.message || "Failed to humanize text", {
        closeButton: true,
        duration: Infinity,
      });
      clearInterval(progressInterval);
      setProgress(0);
    } finally {
      setIsLoading(false);
      setTimeout(() => setProgress(0), 1000);
    }
  };

  const handleReset = () => {
    setInput("");
    setOutput("");
    setProgress(0);
    setActiveTab("input");
  };

  const handleSampleText = (sampleText) => {
    setInput(sampleText);
    setActiveTab("input");
  };

  const copyToClipboard = async (text) => {
    try {
      await navigator.clipboard.writeText(text);
      toast.success("Copied to clipboard!", { duration: 2000 });
    } catch (error) {
      // Fallback for older browsers
      const textArea = document.createElement("textarea");
      textArea.value = text;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand("copy");
      document.body.removeChild(textArea);
      toast.success("Copied to clipboard!", { duration: 2000 });
    }
  };

  // Keyboard shortcuts
  const handleKeyDown = (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
      e.preventDefault();
      handleSubmit(e);
    }
  };

  return (
    <div className="w-full max-w-6xl mx-auto p-4 space-y-6">
      <Card className="bg-card text-card-foreground">
        <CardHeader>
          <div className="flex items-center justify-between">
            <div>
              <CardTitle className="text-3xl font-bold flex items-center gap-2">
                <Zap className="h-8 w-8 text-primary" />
                AI Text Humanizer
              </CardTitle>
              <CardDescription className="text-lg mt-2">
                Transform AI-generated text into natural, human-like writing
              </CardDescription>
            </div>
            
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="outline" size="sm">
                  <FileText className="mr-2 h-4 w-4" />
                  Sample Texts
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent>
                {Object.entries(SAMPLE_TEXTS).map(([name, text]) => (
                  <DropdownMenuItem 
                    key={name} 
                    onClick={() => handleSampleText(text)}
                  >
                    {name}
                  </DropdownMenuItem>
                ))}
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
          
          {isLoading && (
            <div className="mt-4">
              <div className="flex items-center justify-between text-sm text-muted-foreground mb-2">
                <span>Processing your text...</span>
                <span>{Math.round(progress)}%</span>
              </div>
              <Progress value={progress} className="h-2" />
            </div>
          )}
        </CardHeader>

        <CardContent>
          <Tabs value={activeTab} onValueChange={setActiveTab}>
            <TabsList className="grid grid-cols-3 w-full mb-6">
              <TabsTrigger value="input">Input Text</TabsTrigger>
              <TabsTrigger value="output" disabled={!output}>Humanized Text</TabsTrigger>
              <TabsTrigger value="metrics" disabled={!metrics}>
                <BarChart3 className="mr-2 h-4 w-4" />
                Analytics
              </TabsTrigger>
            </TabsList>

            <TabsContent value="input" className="space-y-4">
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <label htmlFor="input" className="text-sm font-medium">
                    AI-Generated Text
                  </label>
                  <Badge variant="secondary">
                    {input.length} characters
                  </Badge>
                </div>
                <Textarea
                  id="input"
                  placeholder="Paste your AI-generated text here... (Press Cmd/Ctrl+Enter to submit)"
                  value={input}
                  onChange={handleInputChange}
                  onKeyDown={handleKeyDown}
                  className="min-h-[300px] resize-y text-base leading-relaxed"
                  disabled={isLoading}
                />
              </div>
            </TabsContent>

            <TabsContent value="output" className="space-y-4">
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <label htmlFor="output" className="text-sm font-medium">
                    Humanized Text
                  </label>
                  <div className="flex gap-2">
                    <Badge variant="secondary">
                      {output.length} characters
                    </Badge>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => copyToClipboard(output)}
                    >
                      <Copy className="mr-2 h-4 w-4" />
                      Copy
                    </Button>
                  </div>
                </div>
                <Textarea
                  id="output"
                  value={output}
                  readOnly
                  className="min-h-[300px] resize-y text-base leading-relaxed bg-muted/50"
                />
              </div>
            </TabsContent>

            <TabsContent value="metrics" className="space-y-6">
              {metrics && (
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                  <Card>
                    <CardContent className="pt-6">
                      <div className="text-2xl font-bold">{metrics.originalWords}</div>
                      <p className="text-xs text-muted-foreground">Original Words</p>
                    </CardContent>
                  </Card>
                  <Card>
                    <CardContent className="pt-6">
                      <div className="text-2xl font-bold">{metrics.humanizedWords}</div>
                      <p className="text-xs text-muted-foreground">Humanized Words</p>
                    </CardContent>
                  </Card>
                  <Card>
                    <CardContent className="pt-6">
                      <div className="text-2xl font-bold text-primary">
                        {metrics.lengthChange > 0 ? '+' : ''}{metrics.lengthChange}%
                      </div>
                      <p className="text-xs text-muted-foreground">Length Change</p>
                    </CardContent>
                  </Card>
                  <Card>
                    <CardContent className="pt-6">
                      <div className="text-2xl font-bold text-green-600">
                        {metrics.readabilityScore}
                      </div>
                      <p className="text-xs text-muted-foreground">Readability Score</p>
                    </CardContent>
                  </Card>
                </div>
              )}
            </TabsContent>
          </Tabs>
        </CardContent>

        <CardFooter className="flex justify-between">
          <Button
            type="button"
            variant="outline"
            onClick={handleReset}
            disabled={isLoading || (!input && !output)}
          >
            <RefreshCw className="mr-2 h-4 w-4" />
            Reset
          </Button>
          
          <div className="flex gap-2">
            <Button 
              type="submit" 
              onClick={handleSubmit}
              disabled={isLoading || !input.trim()}
              size="lg"
            >
              {isLoading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Humanizing...
                </>
              ) : (
                <>
                  <Zap className="mr-2 h-4 w-4" />
                  Humanize Text
                </>
              )}
            </Button>
          </div>
        </CardFooter>
      </Card>
    </div>
  );
}